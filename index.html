<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Clone Stamp - Watermark Remover</title>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --bg-hover: #333333;
            --text-main: #e0e0e0;
            --text-muted: #aaaaaa;
            --accent: #007acc;
            --accent-hover: #0062a3;
            --border: #3e3e42;
            --success: #4caf50;
        }

        * {
            box-sizing: border-box;
            user-select: none; /* Prevent selection while drawing */
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 280px;
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            z-index: 10;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }

        .brand {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.85rem;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
        }

        .value-display {
            color: var(--accent);
            font-weight: 600;
        }

        /* Inputs */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-dark);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: background 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--accent-hover);
        }

        /* Buttons */
        .btn {
            background-color: var(--bg-hover);
            color: var(--text-main);
            border: 1px solid var(--border);
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            background-color: #444;
            border-color: #555;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn-primary {
            background-color: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--accent-hover);
        }

        .btn-secondary {
            background-color: transparent;
        }
        
        .btn-secondary:hover {
            background-color: rgba(255,255,255,0.05);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #1a1a1a;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 5px;
        }
        
        .zoom-btn {
            background: transparent;
            border: none;
            color: var(--text-main);
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }
        
        .zoom-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .zoom-level {
            font-size: 0.85rem;
            font-family: monospace;
            min-width: 50px;
            text-align: center;
        }

        /* Instructions Panel */
        .instructions {
            margin-top: auto;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 6px;
            font-size: 0.8rem;
            line-height: 1.5;
            color: var(--text-muted);
            border-left: 3px solid var(--accent);
        }

        .instructions strong {
            color: var(--text-main);
        }

        .kbd {
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            border-bottom: 2px solid #222;
            font-family: monospace;
            color: white;
        }

        /* --- Workspace --- */
        .workspace {
            flex: 1;
            position: relative;
            background-color: #121212;
            /* Checkboard background for transparency */
            background-image: 
                linear-gradient(45deg, #1a1a1a 25%, transparent 25%), 
                linear-gradient(-45deg, #1a1a1a 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #1a1a1a 75%), 
                linear-gradient(-45deg, transparent 75%, #1a1a1a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            cursor: default;
        }

        /* Container for canvases */
        .canvas-wrapper {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            transform-origin: center center;
            /* Will be transformed by JS */
            transition: transform 0.1s ease-out; 
            cursor: crosshair;
        }
        
        .canvas-wrapper.panning {
            cursor: grab;
        }
        
        .canvas-wrapper.panning:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
            touch-action: none; 
        }

        /* The cursor canvas sits on top */
        #cursorCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* Let events pass through to imageCanvas */
            width: 100%;
            height: 100%;
        }

        /* Hidden file input */
        #fileInput {
            display: none;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--bg-panel);
            color: var(--text-main);
            padding: 12px 20px;
            border-radius: 4px;
            border-left: 4px solid var(--success);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
    </style>
</head>
<body>

    <!-- Sidebar Controls -->
    <aside class="sidebar">
        <div class="brand">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                <path d="M2 2l7.586 7.586"></path>
                <circle cx="11" cy="11" r="2"></circle>
            </svg>
            CloneRemover
        </div>

        <!-- File Operations -->
        <button class="btn btn-primary" id="uploadBtn">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
            Upload Image
        </button>
        <input type="file" id="fileInput" accept="image/*">

        <button class="btn" id="downloadBtn" disabled>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            Save Result
        </button>

        <hr style="width: 100%; border: 0; border-top: 1px solid var(--border);">

        <!-- Zoom Controls -->
        <div class="control-group">
            <label>Zoom</label>
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut" title="Zoom Out">-</button>
                <span class="zoom-level" id="zoomDisplay">100%</span>
                <button class="zoom-btn" id="zoomIn" title="Zoom In">+</button>
            </div>
            <button class="btn btn-secondary" id="zoomFit" style="margin-top: 5px; font-size: 0.8rem; padding: 6px;">
                Fit to Screen
            </button>
        </div>

        <hr style="width: 100%; border: 0; border-top: 1px solid var(--border);">

        <!-- Brush Controls -->
        <div class="control-group">
            <label>Brush Size <span class="value-display" id="sizeVal">30px</span></label>
            <input type="range" id="brushSize" min="1" max="200" value="30">
        </div>

        <div class="control-group">
            <label>Opacity <span class="value-display" id="opacityVal">100%</span></label>
            <input type="range" id="brushOpacity" min="1" max="100" value="100">
        </div>

        <div class="control-group">
            <label>Hardness <span class="value-display" id="hardnessVal">80%</span></label>
            <input type="range" id="brushHardness" min="0" max="100" value="80">
        </div>

        <hr style="width: 100%; border: 0; border-top: 1px solid var(--border);">

        <!-- Edit Actions -->
        <div class="btn-group">
            <button class="btn btn-secondary" id="undoBtn" disabled>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 14L4 9l5-5"></path>
                    <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"></path>
                </svg>
                Undo
            </button>
            <button class="btn btn-secondary" id="resetBtn" disabled>
                Reset
            </button>
        </div>

        <!-- Instructions -->
        <div class="instructions">
            <p><strong>Controls:</strong></p>
            <p>• <span class="kbd">Alt</span> + Click: Set Source</p>
            <p>• <span class="kbd">Drag</span>: Paint (Clone)</p>
            <p>• <span class="kbd">Space</span> + Drag: Pan View</p>
            <p>• <span class="kbd">Wheel</span>: Zoom In/Out</p>
        </div>
    </aside>

    <!-- Main Workspace -->
    <main class="workspace">
        <div class="canvas-wrapper" id="canvasWrapper">
            <canvas id="imageCanvas"></canvas>
            <canvas id="cursorCanvas"></canvas>
        </div>
    </main>

    <!-- Notification -->
    <div class="toast" id="toast">Image Saved!</div>

    <script>
        /**
         * Clone Stamp Tool Logic with Zoom and Pan
         */
        
        // DOM Elements
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const downloadBtn = document.getElementById('downloadBtn');
        const undoBtn = document.getElementById('undoBtn');
        const resetBtn = document.getElementById('resetBtn');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const workspace = document.querySelector('.workspace');
        const imageCanvas = document.getElementById('imageCanvas');
        const cursorCanvas = document.getElementById('cursorCanvas');
        const ctx = imageCanvas.getContext('2d', { willReadFrequently: true });
        const cCtx = cursorCanvas.getContext('2d');

        // Zoom Controls
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomOutBtn = document.getElementById('zoomOut');
        const zoomFitBtn = document.getElementById('zoomFit');
        const zoomDisplay = document.getElementById('zoomDisplay');

        // Inputs
        const brushSizeInput = document.getElementById('brushSize');
        const brushOpacityInput = document.getElementById('brushOpacity');
        const brushHardnessInput = document.getElementById('brushHardness');
        const sizeVal = document.getElementById('sizeVal');
        const opacityVal = document.getElementById('opacityVal');
        const hardnessVal = document.getElementById('hardnessVal');

        // State Variables
        let isDrawing = false;
        let isAltPressed = false;
        let isSpacePressed = false;
        let isPanning = false;
        let hasImage = false;
        let history = [];
        let historyStep = -1;
        const maxHistory = 20;

        // Clone Tool Specifics
        let sourcePoint = { x: 0, y: 0 };
        let dragStartPoint = { x: 0, y: 0 };
        let isSourceSet = false;

        // Brush settings
        let brushSize = 30;
        let brushOpacity = 1.0;
        let brushHardness = 0.8;

        // Zoom and Pan State
        let zoom = 1.0;
        let pan = { x: 0, y: 0 };
        let baseScale = 1.0; // The scale needed to fit image initially
        let minZoom = 0.1;
        let maxZoom = 20.0;
        let panStart = { x: 0, y: 0 }; // For panning drag

        // --- Initialization ---

        function init() {
            canvasWrapper.style.display = 'none';
            
            // File Listeners
            uploadBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleImageUpload);
            downloadBtn.addEventListener('click', downloadImage);
            undoBtn.addEventListener('click', undo);
            resetBtn.addEventListener('click', resetImage);

            // Brush Listeners
            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                sizeVal.textContent = brushSize + 'px';
                drawCursorOverlay();
            });
            brushOpacityInput.addEventListener('input', (e) => {
                brushOpacity = parseInt(e.target.value) / 100;
                opacityVal.textContent = e.target.value + '%';
            });
            brushHardnessInput.addEventListener('input', (e) => {
                brushHardness = parseInt(e.target.value) / 100;
                hardnessVal.textContent = e.target.value + '%';
            });

            // Zoom Listeners
            zoomInBtn.addEventListener('click', () => adjustZoom(1.2));
            zoomOutBtn.addEventListener('click', () => adjustZoom(0.8));
            zoomFitBtn.addEventListener('click', fitToScreen);

            // Keyboard Interaction
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            // Mouse/Touch Interaction
            window.addEventListener('mousemove', onMouseMove); 
            window.addEventListener('mouseup', onMouseUp);
            
            // Wheel Zoom
            workspace.addEventListener('wheel', handleWheel, { passive: false });

            // Initial Cursor Canvas setup
            cursorCanvas.width = 100;
            cursorCanvas.height = 100;
        }

        // --- Image Handling ---

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    setupCanvas(img);
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }

        function setupCanvas(img) {
            imageCanvas.width = img.width;
            imageCanvas.height = img.height;
            cursorCanvas.width = img.width;
            cursorCanvas.height = img.height;

            ctx.drawImage(img, 0, 0);

            hasImage = true;
            canvasWrapper.style.display = 'block';
            isSourceSet = false;
            downloadBtn.disabled = false;
            resetBtn.disabled = false;
            
            history = [];
            historyStep = -1;
            saveState();

            fitToScreen();
        }

        function fitToScreen() {
            if (!hasImage) return;
            
            const wsWidth = workspace.clientWidth;
            const wsHeight = workspace.clientHeight;
            const imgWidth = imageCanvas.width;
            const imgHeight = imageCanvas.height;

            // Calculate scale to fit with some padding
            const scaleX = (wsWidth - 40) / imgWidth;
            const scaleY = (wsHeight - 40) / imgHeight;
            baseScale = Math.min(scaleX, scaleY);
            
            // Don't zoom in if image is tiny
            baseScale = Math.min(baseScale, 1.0); 

            zoom = 1.0; // Reset relative zoom
            pan = { x: 0, y: 0 };
            
            updateTransform();
        }

        function adjustZoom(factor) {
            if (!hasImage) return;
            const newZoom = Math.min(Math.max(minZoom, zoom * factor), maxZoom);
            if (newZoom === zoom) return;
            zoom = newZoom;
            updateTransform();
        }

        function updateTransform() {
            if (!hasImage) return;
            const totalScale = baseScale * zoom;
            
            // Apply CSS transform
            canvasWrapper.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${totalScale})`;
            
            // Update UI
            zoomDisplay.textContent = Math.round(zoom * 100) + '%';
            
            // Redraw cursor to adjust line width/size based on new zoom
            drawCursorOverlay();
        }

        function handleWheel(e) {
            if (!hasImage) return;
            if (e.ctrlKey) {
                e.preventDefault(); // Prevent browser zoom
            }
            
            // Check if hovering over canvas (or workspace)
            if(e.target.closest('.workspace')) {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const oldZoom = zoom;
                let newZoom = zoom * delta;
                newZoom = Math.min(Math.max(minZoom, newZoom), maxZoom);
                
                if (newZoom !== oldZoom) {
                    // Zoom towards mouse pointer logic
                    // 1. Get mouse pos relative to workspace center
                    const rect = workspace.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left - rect.width/2;
                    const mouseY = e.clientY - rect.top - rect.height/2;

                    // 2. Adjust pan so the point under mouse remains static
                    // formula: newOffset = mouse - (mouse - oldOffset) * (newScale / oldScale)
                    const scaleRatio = (newZoom / oldZoom);
                    
                    pan.x = mouseX - (mouseX - pan.x) * scaleRatio;
                    pan.y = mouseY - (mouseY - pan.y) * scaleRatio;
                    
                    zoom = newZoom;
                    updateTransform();
                }
            }
        }

        // --- Interaction Logic ---

        function handleKeyDown(e) {
            if (e.code === 'Space' && !isSpacePressed) {
                isSpacePressed = true;
                if (hasImage) canvasWrapper.classList.add('panning');
            }
            if (e.key === 'Alt') {
                isAltPressed = true;
                drawCursorOverlay();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            // Zoom shortcuts
            if ((e.ctrlKey || e.metaKey) && (e.key === '=' || e.key === '+')) {
                e.preventDefault();
                adjustZoom(1.2);
            }
            if ((e.ctrlKey || e.metaKey) && e.key === '-') {
                e.preventDefault();
                adjustZoom(0.8);
            }
        }

        function handleKeyUp(e) {
            if (e.code === 'Space') {
                isSpacePressed = false;
                isPanning = false;
                if (hasImage) canvasWrapper.classList.remove('panning');
            }
            if (e.key === 'Alt') {
                isAltPressed = false;
                drawCursorOverlay();
            }
        }

        // Attach mousedown to canvas wrapper to capture events
        canvasWrapper.addEventListener('mousedown', onMouseDown);

        function getMousePos(e) {
            // We rely on getBoundingClientRect which respects CSS transforms
            // This makes the math trivial: (screenX - canvasScreenLeft) * (canvasWidth / canvasScreenWidth)
            const rect = imageCanvas.getBoundingClientRect();
            
            // Handle case where canvas is off screen
            if (rect.width === 0 || rect.height === 0) return { x: 0, y: 0 };

            return {
                x: (e.clientX - rect.left) * (imageCanvas.width / rect.width),
                y: (e.clientY - rect.top) * (imageCanvas.height / rect.height)
            };
        }

        function onMouseDown(e) {
            if (!hasImage) return;
            
            // Panning Logic (Space + Drag)
            if (isSpacePressed) {
                isPanning = true;
                panStart = { x: e.clientX - pan.x, y: e.clientY - pan.y };
                return;
            }

            const pos = getMousePos(e);

            // Source Selection Logic (Alt + Click)
            if (e.altKey || isAltPressed) {
                sourcePoint = { x: pos.x, y: pos.y };
                isSourceSet = true;
                drawCursorOverlay();
                showToast('Source point set', 1000);
                return;
            }

            // Drawing Logic
            if (!isSourceSet) {
                showToast('Alt+Click first to set source!');
                return;
            }

            isDrawing = true;
            dragStartPoint = { x: pos.x, y: pos.y };
            saveState();
            performClone(pos.x, pos.y);
        }

        function onMouseMove(e) {
            if (!hasImage) return;

            // Panning
            if (isPanning && isSpacePressed) {
                pan.x = e.clientX - panStart.x;
                pan.y = e.clientY - panStart.y;
                updateTransform(); // This updates visual position
                return; // Don't draw cursor while panning
            }

            // Calculate if over canvas
            const rect = imageCanvas.getBoundingClientRect();
            const isInBounds = e.clientX >= rect.left && e.clientX <= rect.right && 
                               e.clientY >= rect.top && e.clientY <= rect.bottom;

            if (!isInBounds && !isDrawing) {
                cCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
                return;
            }

            const pos = getMousePos(e);

            if (isDrawing) {
                performClone(pos.x, pos.y);
            }

            drawCursorOverlay(pos.x, pos.y);
        }

        function onMouseUp(e) {
            isDrawing = false;
            isPanning = false;
        }

        // --- Core Clone Stamp Logic ---

        const tempCanvas = document.createElement('canvas');
        const tCtx = tempCanvas.getContext('2d');

        function performClone(targetX, targetY) {
            const dx = targetX - dragStartPoint.x;
            const dy = targetY - dragStartPoint.y;

            const sourceX = sourcePoint.x + dx;
            const sourceY = sourcePoint.y + dy;

            const r = brushSize / 2;

            tempCanvas.width = brushSize;
            tempCanvas.height = brushSize;
            tCtx.clearRect(0, 0, brushSize, brushSize);

            // 1. Copy pixels from source
            tCtx.drawImage(
                imageCanvas, 
                sourceX - r, sourceY - r, brushSize, brushSize, 
                0, 0, brushSize, brushSize
            );

            // 2. Create Mask
            tCtx.globalCompositeOperation = 'destination-in';
            
            if (brushHardness >= 0.99) {
                tCtx.fillStyle = '#000';
                tCtx.beginPath();
                tCtx.arc(r, r, r, 0, Math.PI * 2);
                tCtx.fill();
            } else {
                const gradient = tCtx.createRadialGradient(r, r, r * (1 - brushHardness), r, r, r);
                gradient.addColorStop(0, 'rgba(0,0,0,1)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                tCtx.fillStyle = gradient;
                tCtx.fillRect(0, 0, brushSize, brushSize);
            }

            // 3. Apply to canvas
            ctx.globalAlpha = brushOpacity;
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(
                tempCanvas, 
                0, 0, brushSize, brushSize, 
                targetX - r, targetY - r, brushSize, brushSize
            );
            
            ctx.globalAlpha = 1.0;
        }

        // --- Cursor Overlay Logic (Zoom Aware) ---

        function drawCursorOverlay(mouseX, mouseY) {
            cCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);

            // Calculate Current Visual Scale
            // We need this to keep the cursor looking consistent on screen
            const rect = imageCanvas.getBoundingClientRect();
            // How many screen pixels is one image pixel?
            const pixelRatio = rect.width / imageCanvas.width; 

            if (isSourceSet) {
                const s = sourcePoint;
                // Draw Source Marker
                // The source marker should also scale, but we want lines to remain 1px on screen
                // So we divide line width by pixelRatio
                const lw = 1 / pixelRatio;
                
                cCtx.strokeStyle = '#fff';
                cCtx.lineWidth = lw;
                cCtx.beginPath();
                cCtx.moveTo(s.x - 10/pixelRatio, s.y);
                cCtx.lineTo(s.x + 10/pixelRatio, s.y);
                cCtx.moveTo(s.x, s.y - 10/pixelRatio);
                cCtx.lineTo(s.x, s.y + 10/pixelRatio);
                cCtx.stroke();

                cCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                cCtx.beginPath();
                cCtx.arc(s.x, s.y, (brushSize / 2), 0, Math.PI * 2);
                cCtx.stroke();
            }

            if (mouseX !== undefined && mouseY !== undefined) {
                // Draw Brush Cursor
                // We want the brush circle to represent the actual brush size in image pixels.
                // So we just draw at brushSize.
                // BUT, the border width needs to be 1px on screen.
                
                const lw = 1 / pixelRatio;
                
                cCtx.strokeStyle = '#000';
                cCtx.lineWidth = lw + 1/pixelRatio; // slightly thicker for visibility
                cCtx.beginPath();
                cCtx.arc(mouseX, mouseY, brushSize / 2, 0, Math.PI * 2);
                cCtx.stroke();

                cCtx.strokeStyle = '#fff';
                cCtx.lineWidth = lw;
                cCtx.setLineDash([5/pixelRatio, 5/pixelRatio]); // Dashed pattern scales too
                cCtx.stroke();
                cCtx.setLineDash([]);

                if (isAltPressed) {
                    cCtx.fillStyle = '#fff';
                    // Font size should be constant on screen
                    const fontSize = 12 / pixelRatio; 
                    cCtx.font = `${fontSize}px sans-serif`;
                    cCtx.fillText("Set Source", mouseX + 10/pixelRatio, mouseY - 10/pixelRatio);
                }
            }
        }

        // --- History ---

        function saveState() {
            if (historyStep < history.length - 1) {
                history = history.slice(0, historyStep + 1);
            }
            history.push(ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height));
            historyStep++;
            if (history.length > maxHistory) {
                history.shift();
                historyStep--;
            }
            updateUndoButton();
        }

        function undo() {
            if (historyStep > 0) {
                historyStep--;
                ctx.putImageData(history[historyStep], 0, 0);
                updateUndoButton();
            } else if (historyStep === 0) {
                resetImage();
            }
        }

        function updateUndoButton() {
            undoBtn.disabled = historyStep <= 0;
        }

        function resetImage() {
            if (history.length > 0) {
                ctx.putImageData(history[0], 0, 0);
                history = [history[0]];
                historyStep = 0;
                updateUndoButton();
                isSourceSet = false;
                drawCursorOverlay();
            }
        }

        // --- Download ---

        function downloadImage() {
            if (!hasImage) return;
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = imageCanvas.toDataURL('image/png');
            link.click();
            showToast('Image downloaded successfully!');
        }

        // --- Utilities ---

        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        init();
    </script>
</body>
</html>